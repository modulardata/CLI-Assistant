<div class="step-text">
<p>You've probably heard a lot about data leakage, malicious attacks, and especially hackers. Even the biggest tech companies are facing these problems nowadays. To mitigate this, it is necessary to use more effective tools to secure data. One such tool is the <code class="language-javascript">crypto</code> module in Node.js. It provides a bunch of useful methods to secure data, therefore minimizing the risks that somebody gets hold of our private information. Let's take a look at the module and its core methods. You will learn about different classes present in the module, ways to implement hashing and ciphering, and see practical examples of where to use which method.</p><h5 id="cryptography-in-nodejs">Cryptography in Node.js</h5><p>Cryptography in Node.js is all about protecting personal data such as passwords, payment transactions, server communication, and other confidential info. In simple terms, cryptography transforms the original data into another value built up from random characters. This way, only the sender and the intended recipient of data will have access to the data, leaving third parties (hackers) empty-handed. </p><p>Imagine you are building a full-stack application with authorization. You need to save user information (email and password) into a database so that they can log in with their credentials. But what if somebody hacks your database and steals all the data? They'll be able to log in as original users and steal personal information, blackmail people, and commit unethical activities. Eventually, users will lose trust and no longer use your application. This is why cryptography is a must for every computer application or online service.</p><p>Cryptography consists of two main methods — hashing and ciphering (encryption). The methods are similar in their goal. Both methods convert a given string into a random and unreadable string. However, the difference is that hashing is a one-way method. So you can't revert the value back to the original readable text once you hash it. On the other hand, ciphering can encrypt data and then decrypt it if necessary. Another difference is that hashing outputs a fixed-length string, whereas ciphering can be of any length.</p><p>You can use <strong>hashing</strong> in authentication-based applications, i.e. through passwords, or e-commerce apps where you enter your credit card info. This info is turned into a hash digest and there's no way to revert it to the original plaintext. Whenever you enter your password, the server hashes it again and then compares it to the existing hashed password associated with your email. If they're equal, you're good to go. Otherwise, you won't be able to access the application.</p><p style="text-align: center;"><picture><source media="(max-width: 480px)" srcset="https://ucarecdn.com/2b305c1c-8b27-464e-9d4e-3ff74b6e2009/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/2b305c1c-8b27-464e-9d4e-3ff74b6e2009/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/2b305c1c-8b27-464e-9d4e-3ff74b6e2009/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/2b305c1c-8b27-464e-9d4e-3ff74b6e2009/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/2b305c1c-8b27-464e-9d4e-3ff74b6e2009/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/2b305c1c-8b27-464e-9d4e-3ff74b6e2009/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/2b305c1c-8b27-464e-9d4e-3ff74b6e2009/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/2b305c1c-8b27-464e-9d4e-3ff74b6e2009/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/2b305c1c-8b27-464e-9d4e-3ff74b6e2009/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><img alt="hashing-example-img" height="227" src="https://ucarecdn.com/2b305c1c-8b27-464e-9d4e-3ff74b6e2009/" width="473"/></picture></p><p><strong>Ciphering</strong> is good when two servers talk to each other — the first server sends some sensitive data by encrypting it and the second server has a key to decrypt it. This way servers can exchange data securely. Another example is messaging apps, where two people can see each other's messages in plain text format even though the application saves the messages as encrypted values in a database. </p><p style="text-align: center;"><picture><source media="(max-width: 480px)" srcset="https://ucarecdn.com/157f4c65-7d4d-4b5d-be0d-da7f0523ec0b/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/157f4c65-7d4d-4b5d-be0d-da7f0523ec0b/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/157f4c65-7d4d-4b5d-be0d-da7f0523ec0b/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/157f4c65-7d4d-4b5d-be0d-da7f0523ec0b/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/157f4c65-7d4d-4b5d-be0d-da7f0523ec0b/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/157f4c65-7d4d-4b5d-be0d-da7f0523ec0b/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/157f4c65-7d4d-4b5d-be0d-da7f0523ec0b/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/157f4c65-7d4d-4b5d-be0d-da7f0523ec0b/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/157f4c65-7d4d-4b5d-be0d-da7f0523ec0b/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><img alt="encryption-example-img" height="294" src="https://ucarecdn.com/157f4c65-7d4d-4b5d-be0d-da7f0523ec0b/" width="478"/></picture></p><h5 id="an-overview-of-crypto-classes">An overview of crypto classes</h5><p>A few classes in the crypto module allow you to secure apps. These are <code class="language-javascript">Certificate</code>, <code class="language-javascript">Cipher</code>, <code class="language-javascript">Decipher</code>, <code class="language-javascript">DiffieHellman</code>, <code class="language-javascript">ECDH</code>, <code class="language-javascript">Hash</code>, <code class="language-javascript">Hmac</code>, <code class="language-javascript">Sign</code>, and <code class="language-javascript">Verify</code>.</p><p>Let's briefly go over each class to get a general understanding of their function:</p><ul><li><p>You can use <code class="language-javascript">Certificate</code> to create a session key to send data over the Internet securely. The class works with SPKAC (Signed Public Key and Challenge) format, which makes it easy to generate and manipulate a public key via OpenSSL.</p></li><li><p><code class="language-javascript">Cipher</code> is a tool that encrypts a plaintext into a cipher using an algorithm. You can decrypt it back to plaintext using the opposite class called <code class="language-javascript">Decipher</code>. </p></li><li><p><code class="language-javascript">DiffieHellman</code> class is responsible for exchanging a secret key between two parties in public channels. If you're curious and want to dive deeper, refer to an article on <a href="https://www.techtarget.com/searchsecurity/definition/Diffie-Hellman-key-exchange#:~:text=Diffie%2DHellman%20key%20exchange%20is,encrypt%20and%20decrypt%20their%20messages." rel="noopener noreferrer nofollow" target="_blank">Diffie-Hellman key exchange</a>.</p></li><li><p><code class="language-javascript">ECDH</code> is a variation of the previous method that allows two parties to exchange a secret key with the help of a predefined curve. </p></li><li><p>Use the <code class="language-javascript">Hash</code> class to convert texts into hash. Keep in mind that they can't be reverted back. </p></li><li><p><code class="language-javascript">Hmac</code> is an acronym for Hash-based Message Authentication Code. This class provides an encryption method that uses a hash function along with a secret key.</p></li></ul><h5 id="hashing">Hashing</h5><p>You can generate a hash in three simple steps. First, decide on the hashing algorithm. Then add the text you want to hash and finally output it in a desirable format. You can choose from many algorithms, such as <code class="language-javascript">sha512</code>, <code class="language-javascript">sha384</code>, <code class="language-javascript">sm3</code>, and more. You can import the <code class="language-javascript">crypto</code> module and console log <code class="language-javascript">crypto.getHashes()</code> to see all available algorithms. The final format can be <code class="language-javascript">binary</code>, <code class="language-javascript">hex</code>, <code class="language-javascript">base64</code>, <code class="language-javascript">base64url</code>. You can use any of those, though <code class="language-javascript">hex</code> is more popular and convenient.</p><p>Take a look at this example:</p><pre><code class="language-javascript">const crypto = require('node:crypto');

const hashed = crypto.createHash('sm3')
               .update('Hi folks!')
               .digest('hex');

console.log(hashed);
</code></pre><p>First, the code snippet imports the <code class="language-javascript">crypto</code> module. Then it declares the <code class="language-javascript">hashed</code> constant to save the result. The <code class="language-javascript">createHash()</code> method returns a hash object with the specified algorithm (<code class="language-javascript">sm3</code>). The algorithm is the base on which the hashed string is built. Then you pass the string you want to encode into the <code class="language-javascript">update</code> method. Finally, it outputs the result in the <code class="language-javascript">hex</code> format. If you print the <code class="language-javascript">hashed</code> constant, you will get the following output:</p><pre><code class="language-no-highlight">6ad21a976304948ef4a2a9d6af7c88b069b20036a56d358a86e2cafe73ac472a</code></pre><p>The code snippet uses chained code here, but you can do it differently. You can try saving the result of each step into a new constant.</p><h5 id="hmac">HMAC</h5><p>Imagine someone gets access to your code. They can easily figure out how to hack your database. Assume another scenario where you are building an app with another developer and you want your code to work only for the two of you. In this case, you need a secret key that you can share with your trusted peers.</p><p>HMAC (Hash-based Message Authentication Code) can do exactly that. It is similar to the previous example which uses⁣ <code class="language-javascript">crypto.createHash()</code>, but has one small difference — it now requires a private key.</p><p>Here is how HMAC works:</p><pre><code class="language-javascript">const crypto = require('node:crypto');

const secret = 'shrek';

const hash1 = crypto.createHmac('sm3', secret)
                .update('Hi folks!')
                .digest('hex');

console.log(hash1);
// returns d751c2fae8264850797f7621cb8f2186bce3e453db8e824b02727959f7ca466d

const hash2 = crypto.createHmac('sm3', secret)
                .update('Hi folks!')
                .digest('hex');

console.log(hash2);
// returns d751c2fae8264850797f7621cb8f2186bce3e453db8e824b02727959f7ca466d</code></pre><p>The name of the function is <code class="language-javascript">createHmac()</code>. It takes in an algorithm and a key as parameters. The secret keys should be hidden and shared among trusted personnel only. The secret key is visible in this code snippet for demonstration purposes only.</p><p>What happens if we calculate the HMAC hash twice for the same input? Let's see:</p><p>As you can see, both <code class="language-javascript">hash1</code> and <code class="language-javascript">hash2</code> produce identical results. This demonstrates a key property of hash functions, including HMAC: for the same input and the same secret key, they always produce the same output.</p><p>This consistency is crucial for verifying data integrity and authenticity. However, it's important to note that this predictability can also be a weakness in certain scenarios. If hackers somehow figure out that a specific plaintext results in a given hash, it could potentially make it easier for them to decode other data.</p><p>You can use both <code class="language-javascript">crypto.createHash()</code> and <code class="language-javascript">crypto.createHmac()</code>. But ideally, you would want two unique hashes even when passing the same string ("Hi folks!" in this case). Now, let's learn about some advanced hashing!</p><h5 id="hashing-with-scrypt">Hashing with scrypt</h5><p>The way to get a unique hash is to add salt to it. In simple terms, salt is the random data you add to the beginning of a given string. Usually, salt is different each time, and it's impossible to figure out where it starts and ends in the output. Just like with meals, when you add salt, you can no longer separate it from food. That's why salting is a good technique to secure data.</p><p>Here is a function that returns unique hashes. It uses <code class="language-javascript">crypto.scrypt()</code> (pronounced "ess crypt") method:</p><pre><code class="language-javascript">const hashWithScrypt = (string) =&gt; {
   const currentSalt = crypto.randomBytes(16);

   crypto.scrypt(string, currentSalt, 32, (err, buffer) =&gt; {
      if (err) {
         console.log(err);
      }
      console.log(buffer.toString('hex'));
   });
};</code></pre><p>The function accepts one parameter. It is the string you want to hash. Then it generates salt using <code class="language-javascript">crypto.randomBytes()</code> method. The method takes in <code class="language-javascript">size</code> in bytes; 16 in this case. You can specify a different value if you want. Also, you can run the method asynchronously. This way it takes two parameters — the size and the callback. For simplicity, this snippet works synchronously.</p><p>Now, let's talk about <code class="language-javascript">crypto.scrypt()</code> method's arguments in detail: </p><ul><li><p><code class="language-javascript">string</code> ⁣— the value you want to hash</p></li><li><p><code class="language-javascript">currentSalt</code> ⁣— the salt</p></li><li><p><code class="language-javascript">length</code> ⁣— the length of the output in bytes</p></li><li><p><code class="language-javascript">callback</code> — the function that runs when you successfully create a hash. It takes <code class="language-javascript">err</code> as a parameter and <code class="language-javascript">buffer</code>. <code class="language-javascript">err</code> lets you know when something goes wrong. The <code class="language-javascript">buffer</code> is the actual output.</p></li></ul><p>Working with buffer isn't convenient, so the code converts it to hex using <code class="language-javascript">toString()</code> method.</p><p>Let's check if you can get two unique hash values for identical strings:</p><pre><code class="language-javascript">hashWithScrypt('Hi folks!');
hashWithScrypt('Hi folks!');
// returns 1196f1f865941941c99d4cf9fd1ad01850aab299e7c5de65a30eca5d1e43ff9c
// returns ced4544c3d2e9d94cd56dfc21fc84d10a39a45e8c1b1637fa5f754b146d472fc</code></pre><p>It returns two different values for an identical input string.</p><h5 id="ciphering">Ciphering</h5><p>The <code class="language-javascript">crypto.createCipheriv()</code> and <code class="language-javascript">crypto.createDecipheriv()</code> are two methods with opposite functions. The first one creates a cipher method that you can use to encrypt messages, whereas the second one allows you to decrypt those messages. However, their syntax is similar.</p><p>Let's start with <code class="language-javascript">createCipheriv()</code>. Just like with hashes, it takes three steps to encode a message.</p><p><strong>Step 1: Create a cipher</strong></p><pre><code class="language-javascript">crypto.createCipheriv(algorithm, key, iv, options)</code></pre><ul><li><p><code class="language-javascript">algorithm</code> — a name of the ciphering algorithm. You can check the existing ones by console logging <code class="language-javascript">crypto.getCiphers()</code></p></li><li><p><code class="language-javascript">key</code>⁣— a secret key shared among the dev team</p></li><li><p><code class="language-javascript">iv</code> — initialization vector — a sort of salt that randomizes the output</p></li><li><p><code class="language-javascript">options</code>⁣ — additional properties you need to include when working with <code class="language-javascript">CCM</code>, <code class="language-javascript">OCB</code> algorithms</p></li></ul><p>Here's a visual representation of step one:</p><pre><code class="language-javascript">const iv = crypto.randomBytes(16);

const key = '-32bits--32bits--32bits--32bits-';

const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);</code></pre><p>First, it generates <code class="language-javascript">iv</code> (a random value of 16 bytes). Then it initializes a <code class="language-javascript">key</code> that is 32 characters long (equivalent to 32 bytes). This is important because 256-bit algorithms only accept 32-byte keys (32 bytes = 256 bits). When you try to use any other length, the program throws an error. Finally, you make a cipher that takes in the <code class="language-javascript">algorithm</code>, the <code class="language-javascript">key</code>, and <code class="language-javascript">iv</code>. </p><p><strong>Step 2: Add a message</strong></p><p>Now that you have a cipher, use it to add your message:</p><pre><code class="language-javascript">const updated = cipher.update('Hey beautiful people!', 'utf-8', 'hex');</code></pre><p>In this line of code, you pass the message to the <code class="language-javascript">update</code> method along with the input encoding (utf-8) and output encoding (hex). If you don't specify the latter two parameters, you'll get buffer format by default. </p><p><strong>Step 3: End the process</strong></p><p>In the last step, you need to call the <code class="language-javascript">final</code> method to let the program know that you want to finish the process. Once you call it, you will no longer be able to use the <code class="language-javascript">Cipher</code> object to encrypt data:</p><pre><code class="language-javascript">const ciphered = updated + cipher.final('hex');</code></pre><p>The code line above concatenates the result of the previous step and the result of calling the <code class="language-javascript">final</code> method. Here, the <code class="language-javascript">hex</code> argument specifies the output encoding.</p><p>That's it! If you console log the <code class="language-javascript">ciphered</code> constant, you'll see a ciphered string.</p><p>Now let's become hackers and try to decode the message. It's simple and takes three steps:</p><pre><code class="language-javascript">const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);

const updatedDecipher = decipher.update(ciphered, 'hex', 'utf-8');

const deciphered = updatedDecipher + decipher.final('utf-8');

console.log(deciphered);</code></pre><p>It looks similar to the previous method. The difference is that you are passing in the ciphered message instead of plain text and you are swapping the encodings — you are giving the <code class="language-javascript">hex</code> encoding and awaiting the <code class="language-javascript">utf-8</code> format as a result. The <code class="language-javascript">key</code> and <code class="language-javascript">iv</code> are the same as you used in the initial encryption process above. You were able to decrypt the hashed message, which is:</p><pre><code class="language-no-highlight">Hey beautiful people!</code></pre><h5 id="conclusion">Conclusion</h5><p>Cryptography is an interesting and useful field of study that helps you build more secure apps. In this topic, you read mainly about hashing and ciphering methods of the <code class="language-javascript">crypto</code> module. Once you become comfortable using this module, you can look at some alternatives like <em>bcrypt</em>. </p>
</div>