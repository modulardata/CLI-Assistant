<div class="step-text">
<p>Performance hooks in Node.js let you measure and analyze your applications' performance. They help you to gather data related to performance during your code execution, such as CPU and memory usage, event loop delays, and function execution times. Performance hooks assist you in finding performance issues, refining your code, and enhancing the overall performance of your Node.js applications. In this topic, you will understand the significance of performance and how to measure performance in Node.js using performance hooks.</p> <h5 id="why-is-performance-important">Why is performance important?</h5><p>Performance is essential in Node.js development for various reasons; the user experience is one of the most significant reasons. Performance directly affects your application's user experience. Users prefer quick and responsive applications. Slow responses, delays, and prolonged loading times can irritate users and result in a poor user experience. By enhancing your Node.js application's performance, you can guarantee a smooth and seamless user experience, thereby increasing user satisfaction and engagement. </p><p>An additional reason to optimize performance is scalability. When your application deals with high traffic or numerous concurrent requests, performance issues or bottlenecks can become more noticeable. By identifying and addressing these performance issues, you can make sure your application can handle an increased load, thus scaling effectively.</p><p>Enhancing performance also helps optimize system resource usage such as CPU, memory, and network bandwidth. By decreasing unnecessary computations, refining algorithms, and minimizing resource usage, you can make your application more efficient and cut operational costs.</p><p>In short, performance optimization is significant for delivering a quick, efficient, and reliable user experience, ensuring scalability, and remaining competitive in the market.</p> <h5 id="performance-hooks-usage">Performance hooks usage</h5><p>To use performance hooks in Node.js, you can import the <code class="language-javascript">performance</code> object from the <code class="language-javascript">perf_hooks</code>module using ES6 syntax:</p><pre><code class="language-javascript">import { performance } from 'perf_hooks';</code></pre><p>The <code class="language-javascript">performance</code> object provides several methods and properties that you can use to measure performance. Here's how you can use them: </p><p><code class="language-javascript">performance.now()</code>: This method offers a high-resolution timestamp in milliseconds. You can use it to measure the passed time between two points in your code:</p><pre><code class="language-javascript">const start = performance.now();
// Code to measure
const end = performance.now();
const duration = end - start;
console.log(`Execution time: ${duration} milliseconds`);</code></pre><p><code class="language-javascript">performance.mark()</code>: This method permits you to create a named performance mark in your code. Marks are helpful for measuring the duration between two points or segments of your code:</p><pre><code class="language-javascript">performance.mark('start');
// Code to measure
performance.mark('end');
performance.measure('duration', 'start', 'end'); // explained below
const measurements = performance.getEntriesByName('duration'); // explained below
console.log(`Execution time: ${measurements[0].duration} milliseconds`);</code></pre><p><code class="language-javascript">performance.measure(name, start, end)</code>: This method creates a named performance measure that represents the duration between two marks. It accepts three arguments: the measure's name, the name of the start mark, and the name of the end mark.</p><p><code class="language-javascript">performance.getEntriesByName()</code>: This method gives an array of performance entries with a specific name. You can use it to retrieve the measurements of a particular measure.</p> <h5 id="performance-observer">Performance observer</h5><p>The <code class="language-javascript">PerformanceObserver</code> class in Node.js is a built-in class provided by the <code class="language-javascript">perf_hooks</code> module, offering another way to measure performance. It enables you to observe and collect performance entries for various performance metrics in your Node.js applications.</p><p>Here's an explanation of the <code class="language-javascript">PerformanceObserver</code> class and how to use it:</p><pre><code class="language-javascript">import { PerformanceObserver } from 'perf_hooks';

const observer = new PerformanceObserver((list, observer) =&gt; {
  // Callback function to handle performance entries
});
</code></pre><p>The constructor needs a callback function as a parameter, invoked whenever new performance entries are recorded.</p><pre><code class="language-javascript">observer.observe({ entryTypes: ['measure'], buffered: true });</code></pre><p>To start observing performance entries, you can call the <code class="language-javascript">observe</code> method on the <code class="language-javascript">PerformanceObserver</code> instance. The <code class="language-javascript">observe</code> method requires an options object as an argument, where you can specify the types of performance entries you want to observe using the <code class="language-javascript">entryTypes</code>property. You can also indicate whether to include buffered entries using the <code class="language-javascript">buffered</code> property. This allows the observer to receive a batch of entries that were recorded before the observer was set up. This is useful when you want to get performance data that was recorded before setting up the observer.</p><pre><code class="language-javascript">const handleEntries = (list, observer) =&gt; {
  const entries = list.getEntries();
  // Process performance entries
};

observer.observe({ entryTypes: ['measure'], buffered: true });</code></pre><p>In the callback function given to the <code class="language-javascript">PerformanceObserver</code> constructor, you can access the list of performance entries using the <code class="language-javascript">getEntries</code> method of the <code class="language-javascript">PerformanceObserverEntryList</code> object. The <code class="language-javascript">getEntries</code> method provides an array of performance entries recorded since the last time the callback was invoked. Inside the callback, you can process and analyze the performance entries according to your requirements.</p><pre><code class="language-javascript">observer.disconnect();</code></pre><p>If you wish to stop observing performance entries, you can call the <code class="language-javascript">disconnect</code> method on the <code class="language-javascript">PerformanceObserver</code> instance.</p> <h5 id="measuring-an-async-functions-performance">Measuring an async function's performance</h5><p>Assume you are fetching data from an API, let's see how you can use performance hooks to measure this process's performance.</p><pre><code class="language-javascript">import { performance, PerformanceObserver } from 'perf_hooks';

// Create an asynchronous function to measure its performance
async function fetchData() {
  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      resolve('Data fetched successfully');
    }, 2000); // Simulating an asynchronous operation that takes 2 seconds
  });
}

// Create a performance observer to measure the duration of the asynchronous function
const observer = new PerformanceObserver((list) =&gt; {
  const entries = list.getEntries();
  console.log(`Execution time: ${entries[0].duration} milliseconds`);
});

observer.observe({ entryTypes: ['measure'] });

// Start measuring the performance
performance.mark('start');

fetchData().then(() =&gt; {
  performance.mark('end');
  performance.measure('fetchData', 'start', 'end');
});

// Output: Execution time: 2000.721127986908 milliseconds</code></pre><p>In this example, we have an asynchronous function named <code class="language-javascript">fetchData</code> that simulates an asynchronous operation using a <code class="language-javascript">setTimeout</code> function. We want to measure this asynchronous function's duration using performance hooks.</p><p>First, we import the necessary modules <code class="language-javascript">performance</code> and <code class="language-javascript">PerformanceObserver</code> from the <code class="language-javascript">perf_hooks</code> module. After that, we create the asynchronous function <code class="language-javascript">fetchData</code> that returns a promise. Inside this promise, we use <code class="language-javascript">setTimeout</code> to simulate an asynchronous operation that takes 2 seconds.</p><p>Next, we create a <code class="language-javascript">PerformanceObserver</code> to observe the performance measurements. In the observer's callback, we get the performance entries and log the asynchronous function's duration.</p><p>Then, we mark the start of the performance measurement by using <code class="language-javascript">performance.mark('start')</code>. After that, we call the <code class="language-javascript">fetchData</code> function and add a <code class="language-javascript">.then</code> method to mark the end of the performance measurement by using <code class="language-javascript">performance.mark('end')</code> and we measure the duration by using <code class="language-javascript">performance.measure('fetchData', 'start', 'end')</code>.</p><p>The performance observer will capture the measurement and log the execution time of the asynchronous function. The result might vary.</p> <h5 id="conclusion">Conclusion</h5><p>In conclusion, Node.js's performance hooks, such as the <code class="language-javascript">performance</code> object and the <code class="language-javascript">PerformanceObserver</code> class, offer valuable tools for measuring and analyzing your applications' performance. By using these hooks, you can monitor various performance metrics, find bottlenecks, and refine your code to boost your Node.js applications' overall performance. By continually monitoring and enhancing performance, you can develop quicker, more responsive, and more efficient Node.js applications that offer a smooth user experience, improve conversion rates, and meet your users' expectations.</p>
</div>